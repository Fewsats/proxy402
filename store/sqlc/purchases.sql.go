// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: purchases.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPurchase = `-- name: CreatePurchase :one
INSERT INTO purchases (
    short_code, target_url, method, price, is_test,
    payment_payload, settle_response, paid_route_id, paid_to_address,
    created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id
`

type CreatePurchaseParams struct {
	ShortCode      string
	TargetUrl      string
	Method         string
	Price          int32
	IsTest         bool
	PaymentPayload []byte
	SettleResponse []byte
	PaidRouteID    int64
	PaidToAddress  string
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

// CreatePurchase creates a new purchase record.
func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPurchase,
		arg.ShortCode,
		arg.TargetUrl,
		arg.Method,
		arg.Price,
		arg.IsTest,
		arg.PaymentPayload,
		arg.SettleResponse,
		arg.PaidRouteID,
		arg.PaidToAddress,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getDailyStats = `-- name: GetDailyStats :many
SELECT 
    to_char(p.created_at AT TIME ZONE 'UTC', 'YYYY-MM-DD') AS date,
    COUNT(*) AS count,
    SUM(p.price) AS earnings,
    COUNT(CASE WHEN p.is_test = true THEN 1 END) AS test_count,
    COALESCE(SUM(CASE WHEN p.is_test = true THEN p.price ELSE 0 END), 0) AS test_earnings,
    COUNT(CASE WHEN p.is_test = false THEN 1 END) AS real_count,
    COALESCE(SUM(CASE WHEN p.is_test = false THEN p.price ELSE 0 END), 0) AS real_earnings
FROM 
    purchases p
JOIN 
    paid_routes pr ON p.paid_route_id = pr.id
WHERE 
    pr.user_id = $1
    AND p.created_at >= CURRENT_TIMESTAMP - ($2 || ' days')::INTERVAL
GROUP BY 
    date
ORDER BY 
    date DESC
`

type GetDailyStatsParams struct {
	UserID  int64
	Column2 pgtype.Text
}

type GetDailyStatsRow struct {
	Date         string
	Count        int64
	Earnings     int64
	TestCount    int64
	TestEarnings interface{}
	RealCount    int64
	RealEarnings interface{}
}

// GetDailyStats retrieves daily purchase stats for a specific user.
func (q *Queries) GetDailyStats(ctx context.Context, arg GetDailyStatsParams) ([]GetDailyStatsRow, error) {
	rows, err := q.db.Query(ctx, getDailyStats, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyStatsRow
	for rows.Next() {
		var i GetDailyStatsRow
		if err := rows.Scan(
			&i.Date,
			&i.Count,
			&i.Earnings,
			&i.TestCount,
			&i.TestEarnings,
			&i.RealCount,
			&i.RealEarnings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseByID = `-- name: GetPurchaseByID :one
SELECT id, short_code, target_url, method, price, is_test, payment_payload, settle_response, paid_route_id, paid_to_address, created_at, updated_at FROM purchases
WHERE id = $1
`

// GetPurchaseByID returns a purchase by ID.
func (q *Queries) GetPurchaseByID(ctx context.Context, id int64) (Purchase, error) {
	row := q.db.QueryRow(ctx, getPurchaseByID, id)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.TargetUrl,
		&i.Method,
		&i.Price,
		&i.IsTest,
		&i.PaymentPayload,
		&i.SettleResponse,
		&i.PaidRouteID,
		&i.PaidToAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTotalStats = `-- name: GetTotalStats :one
SELECT 
    COALESCE(SUM(p.price), 0) AS total_earnings,
    COUNT(*) AS total_count
FROM 
    purchases p
JOIN 
    paid_routes pr ON p.paid_route_id = pr.id
WHERE 
    pr.user_id = $1
`

type GetTotalStatsRow struct {
	TotalEarnings interface{}
	TotalCount    int64
}

// GetTotalStats retrieves total purchase stats for a specific user.
func (q *Queries) GetTotalStats(ctx context.Context, userID int64) (GetTotalStatsRow, error) {
	row := q.db.QueryRow(ctx, getTotalStats, userID)
	var i GetTotalStatsRow
	err := row.Scan(&i.TotalEarnings, &i.TotalCount)
	return i, err
}

const listPurchasesByUserID = `-- name: ListPurchasesByUserID :many
SELECT p.id, p.short_code, p.target_url, p.method, p.price, p.is_test, p.payment_payload, p.settle_response, p.paid_route_id, p.paid_to_address, p.created_at, p.updated_at FROM purchases p
JOIN paid_routes pr ON p.paid_route_id = pr.id
WHERE pr.user_id = $1
ORDER BY p.created_at DESC
`

// ListPurchasesByUserID retrieves all purchases for a specific user via paid_routes.
func (q *Queries) ListPurchasesByUserID(ctx context.Context, userID int64) ([]Purchase, error) {
	rows, err := q.db.Query(ctx, listPurchasesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Purchase
	for rows.Next() {
		var i Purchase
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.TargetUrl,
			&i.Method,
			&i.Price,
			&i.IsTest,
			&i.PaymentPayload,
			&i.SettleResponse,
			&i.PaidRouteID,
			&i.PaidToAddress,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
