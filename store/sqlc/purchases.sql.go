// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: purchases.sql

package sqlc

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPurchase = `-- name: CreatePurchase :one
INSERT INTO purchases (
    short_code, target_url, method, price, is_test,
    payment_payload, settle_response, paid_route_id, paid_to_address,
    created_at, updated_at,
    type, credits_available, credits_used, payment_header
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11,
    $12, $13, $14, $15
) RETURNING id
`

type CreatePurchaseParams struct {
	ShortCode        string
	TargetUrl        string
	Method           string
	Price            int32
	IsTest           bool
	PaymentPayload   []byte
	SettleResponse   []byte
	PaidRouteID      int64
	PaidToAddress    string
	CreatedAt        time.Time
	UpdatedAt        time.Time
	Type             string
	CreditsAvailable int32
	CreditsUsed      int32
	PaymentHeader    pgtype.Text
}

// CreatePurchase creates a new purchase record.
func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPurchase,
		arg.ShortCode,
		arg.TargetUrl,
		arg.Method,
		arg.Price,
		arg.IsTest,
		arg.PaymentPayload,
		arg.SettleResponse,
		arg.PaidRouteID,
		arg.PaidToAddress,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Type,
		arg.CreditsAvailable,
		arg.CreditsUsed,
		arg.PaymentHeader,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getDailyStats = `-- name: GetDailyStats :many
SELECT 
    to_char(p.created_at AT TIME ZONE 'UTC', 'YYYY-MM-DD') AS date,
    COUNT(*) AS count,
    SUM(p.price) AS earnings,
    COUNT(CASE WHEN p.is_test = true THEN 1 END) AS test_count,
    COALESCE(SUM(CASE WHEN p.is_test = true THEN p.price ELSE 0 END), 0) AS test_earnings,
    COUNT(CASE WHEN p.is_test = false THEN 1 END) AS real_count,
    COALESCE(SUM(CASE WHEN p.is_test = false THEN p.price ELSE 0 END), 0) AS real_earnings
FROM 
    purchases p
JOIN 
    paid_routes pr ON p.paid_route_id = pr.id
WHERE 
    pr.user_id = $1
    AND p.created_at >= CURRENT_TIMESTAMP - ($2 || ' days')::INTERVAL
GROUP BY 
    date
ORDER BY 
    date DESC
`

type GetDailyStatsParams struct {
	UserID  int64
	Column2 pgtype.Text
}

type GetDailyStatsRow struct {
	Date         string
	Count        int64
	Earnings     int64
	TestCount    int64
	TestEarnings interface{}
	RealCount    int64
	RealEarnings interface{}
}

// GetDailyStats retrieves daily purchase stats for a specific user.
func (q *Queries) GetDailyStats(ctx context.Context, arg GetDailyStatsParams) ([]GetDailyStatsRow, error) {
	rows, err := q.db.Query(ctx, getDailyStats, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyStatsRow
	for rows.Next() {
		var i GetDailyStatsRow
		if err := rows.Scan(
			&i.Date,
			&i.Count,
			&i.Earnings,
			&i.TestCount,
			&i.TestEarnings,
			&i.RealCount,
			&i.RealEarnings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPurchaseByID = `-- name: GetPurchaseByID :one
SELECT id, short_code, target_url, method, price, is_test, payment_payload, settle_response, paid_route_id, paid_to_address, created_at, updated_at, type, credits_available, credits_used, payment_header FROM purchases
WHERE id = $1
`

// GetPurchaseByID returns a purchase by ID.
func (q *Queries) GetPurchaseByID(ctx context.Context, id int64) (Purchase, error) {
	row := q.db.QueryRow(ctx, getPurchaseByID, id)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.TargetUrl,
		&i.Method,
		&i.Price,
		&i.IsTest,
		&i.PaymentPayload,
		&i.SettleResponse,
		&i.PaidRouteID,
		&i.PaidToAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Type,
		&i.CreditsAvailable,
		&i.CreditsUsed,
		&i.PaymentHeader,
	)
	return i, err
}

const getPurchaseByRouteIDAndPaymentHeader = `-- name: GetPurchaseByRouteIDAndPaymentHeader :one
SELECT id, short_code, target_url, method, price, is_test, payment_payload, settle_response, paid_route_id, paid_to_address, created_at, updated_at, type, credits_available, credits_used, payment_header FROM purchases
WHERE paid_route_id = $1 AND payment_header = $2
ORDER BY created_at DESC LIMIT 1
`

type GetPurchaseByRouteIDAndPaymentHeaderParams struct {
	PaidRouteID   int64
	PaymentHeader pgtype.Text
}

func (q *Queries) GetPurchaseByRouteIDAndPaymentHeader(ctx context.Context, arg GetPurchaseByRouteIDAndPaymentHeaderParams) (Purchase, error) {
	row := q.db.QueryRow(ctx, getPurchaseByRouteIDAndPaymentHeader, arg.PaidRouteID, arg.PaymentHeader)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.TargetUrl,
		&i.Method,
		&i.Price,
		&i.IsTest,
		&i.PaymentPayload,
		&i.SettleResponse,
		&i.PaidRouteID,
		&i.PaidToAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Type,
		&i.CreditsAvailable,
		&i.CreditsUsed,
		&i.PaymentHeader,
	)
	return i, err
}

const getTotalStats = `-- name: GetTotalStats :one
SELECT 
    COALESCE(SUM(p.price), 0) AS total_earnings,
    COUNT(*) AS total_count
FROM 
    purchases p
JOIN 
    paid_routes pr ON p.paid_route_id = pr.id
WHERE 
    pr.user_id = $1
`

type GetTotalStatsRow struct {
	TotalEarnings interface{}
	TotalCount    int64
}

// GetTotalStats retrieves total purchase stats for a specific user.
func (q *Queries) GetTotalStats(ctx context.Context, userID int64) (GetTotalStatsRow, error) {
	row := q.db.QueryRow(ctx, getTotalStats, userID)
	var i GetTotalStatsRow
	err := row.Scan(&i.TotalEarnings, &i.TotalCount)
	return i, err
}

const incrementPurchaseCreditsUsed = `-- name: IncrementPurchaseCreditsUsed :exec
UPDATE purchases
SET credits_used = credits_used + 1, updated_at = $2
WHERE id = $1 AND credits_used < credits_available
`

type IncrementPurchaseCreditsUsedParams struct {
	ID        int64
	UpdatedAt time.Time
}

func (q *Queries) IncrementPurchaseCreditsUsed(ctx context.Context, arg IncrementPurchaseCreditsUsedParams) error {
	_, err := q.db.Exec(ctx, incrementPurchaseCreditsUsed, arg.ID, arg.UpdatedAt)
	return err
}

const listPurchasesByUserID = `-- name: ListPurchasesByUserID :many
SELECT p.id, p.short_code, p.target_url, p.method, p.price, p.is_test, p.payment_payload, p.settle_response, p.paid_route_id, p.paid_to_address, p.created_at, p.updated_at, p.type, p.credits_available, p.credits_used, p.payment_header FROM purchases p
JOIN paid_routes pr ON p.paid_route_id = pr.id
WHERE pr.user_id = $1
ORDER BY p.created_at DESC
`

// ListPurchasesByUserID retrieves all purchases for a specific user via paid_routes.
func (q *Queries) ListPurchasesByUserID(ctx context.Context, userID int64) ([]Purchase, error) {
	rows, err := q.db.Query(ctx, listPurchasesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Purchase
	for rows.Next() {
		var i Purchase
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.TargetUrl,
			&i.Method,
			&i.Price,
			&i.IsTest,
			&i.PaymentPayload,
			&i.SettleResponse,
			&i.PaidRouteID,
			&i.PaidToAddress,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Type,
			&i.CreditsAvailable,
			&i.CreditsUsed,
			&i.PaymentHeader,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
